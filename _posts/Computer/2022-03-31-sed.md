---
title: "2022-03-31-sed"
lang: "ko"
layout: page
date: 2022-03-31 20:09:22 +9000
tags: "Computer"
type: documents
---
<!-- [[Computer]] -->

`sed`에 대해 잘 정리한 [블로그 글](https://soooprmx.com/sed-%ec%82%ac%ec%9a%a9%eb%b2%95-2/)이 있어, 이를 아래에 요약해서 옮겨본다. [missing semester](https://missing-semester-kr.github.io/2020/data-wrangling/)에서 `sed`를 사용하는 모습은 정말 마법처럼 보였던 기억이 난다.

## SED란?

`sed`는 옛날 `ed` 에디터 위에 구축된 '스트림 에디터(Stream Editor)'로, 기본적으로 파일의 내용을 직접 조작하는 대신(vim과 같은 텍스트 편집기를 열어서 직접 내용을 수정하는 등...), 파일을 수정하는 방법에 대한 짧은 명령들을 제공한다.

`sed` 명령은 기본적으로 *입력받는 파일들*과 *문자열을 처리할 스크립트*를 전달하여 실행한다. 그 외의 몇 가지 동작 방식을 제어하는 *옵션 스위치*가 있다.

```sh
sed [옵션] 스크립트 입력파일1 [입력파일2 ... ]
```

아무런 옵션이 주어지지 않을 때, 첫 번째 인자는 편집 작업에 사용되는 스크립트가 되고, 이후 입력 파일들을 받는다. 입력파일이 주어지지 않은 경우에는 *표준입력*으로부터 콘텐츠를 읽게 된다. 입력 파일이 2개 이상인 경우에는, 이어진 파일 하나처럼 취급된다.

## 옵션

`sed` 명령에서 사용되는 옵션은 아래와 같다(GNU sed 기준. macOS에서는 잘 작동하지 않는 명령들이 있다.):

| 옵션/스위치         | 별칭                  | 기능                                                             |
| ------------------- | --------------------- | ---------------------------------------------------------------- |
| `-n`                | `--quiet`, `--silent` | 읽어들인 라인을 암시적으로 자동출력하는 것을 중단한다.           |
| `-e`                | `--expression=script` | 실행될 명령에 스크립트를 추가한다.                               |
| `-f script_file`    | `--file=script_file`  | 스크립트 파일의 내용을 가져와서 추가로 실행한다.                 |
| `--follow-symlinks` |                       | 제자리 처리 시에 심볼릭 링크를 따르도록 한다. 하드링크는 꺠진다. |
| `-i[SUFFIX]`        | `--in-place[=SUFFIX]` | 파일을 제자리 처리한다(즉 변경된 내용을 파일에 적용한다).        |
| `-c`                | `--copy`              | 제자리 처리 시에 사본을 이용한다.                                |
| `-l N`              | `--line-length=N`     | 한 줄의 길이를 정의한다.                                         |
|                     | `--posix`             | 모든 GNU확장을 제외한다.                                         |
| `-r`                | `--regexp-extended`   | 확장된 정규식 패턴을 사용한다.                                   |
| `-s`                | `--separate`          | 파일을 하나의 긴 스트림이 아닌 분리된 데이터들로 처리한다.       |
| `-u`                | `-unbuffered`         | 입력으로부터 최소한의 내용만 읽고 더 자주 플러시한다.            |
|                     | `--help`              | 도움말을 표시한다.                                               |

`-e`, `-f` 옵션의 첫 필수 인자(파일이름)는 처리해야 하는 스크립트로 받아들여진다.

## SED의 편집 명령 체계

### 어드레스

기본적으로 `sed`의 편집에 사용되는 스크립트명령은 모든 라인에 대해 반복해서 적용되지만, 특정 행의 범위나 주어진 패턴에만 매칭하는 식으로 편집 명령이 적용되는 영역을 제한하기 위해 "어드레스"를 사용한다. 하나의 어드레스가 주어지는 경우, 해당 어드레스에 매치되는 입력줄에 명령이 적용된다. 두 개의 어드레스가 주어지는 경우, 첫 번째 어드레스부터 두 번째 어드레스까지 이르는 포괄적인 구간에 대해서 적용된다. 첫 번째 어드레스로 지정된 행은 항상 적용된다. 지원 가능한 어드레스 타입은 아래와 같다:

| 어드레스 형식 | 해설                                                                                                            |
| ------------- | --------------------------------------------------------------------------------------------------------------- |
| `number`      | 숫자는 특정한 행 번호에 적용된다.                                                                               |
| `first~step`  | 첫 번째 어드레스가 가리키는 행부터 `step` 라인마다 한 번씩                                                      |
| `$`           | 마지막 행                                                                                                       |
| `/regexp/`    | 정규식 패턴에 매치되는 값이 있는 라인                                                                           |
| `\cregexpc`   | `c`는 임의의 문자일 수 있는데, 역시 정규식을 가리킨다.                                                          |
| `0,addr2`     | `1,addr2`에서 `addr2`가 정규식이면서 1번 행에 매치될 때 정상적으로 처리되지 않는 문제를 해결하기 위해 사용한다. |
| `addr1,+N`    | `addr1`외에 `N`행 만큼 더 선택한다.                                                                             |
| `addr1,~N`    | `addr1`외에 처음으로 만나는 `N`의 배수행까지 선택한다.                                                          |

## 명령

`sed`내의 명령은 기본적으로 각 라인에 대해 적용된다. 모든 명령은 매 라인에서 호출되는 것을 기본으로 하나, 특정한 줄 번호 혹은 패턴에 매치되는 등의 조건을 만족하는 경우에만 적용하게 할 수도 있다. 이렇게 명령의 범위를 한정하기 위해 "어드레스"를 사용한다.

### 1개 혹은 0개의 어드레스를 받는 명령

| 명령           | 의미                                                                                    |
| -------------- | --------------------------------------------------------------------------------------- |
| `=`            | 행 번호를 출력한다.                                                                     |
| `a \ text`     | 개행문자 앞에 역슬래시를 붙여서 여러 줄을 포함할 수 있는 텍스트를 뒤에 붙인다.          |
| `i \ text`     | 개행문자 앞에 역슬래시를 붙여서 여러 줄을 포함할 수 있는 텍스트를 해당 영역에 삽입한다. |
| `q[exit_code]` | 해당 영역에서 종료한다.                                                                 |
| `Q[exit_code]` | 더 이상의 입력을 받지 않고 즉시 종료한다.                                               |
| `r filename`   | 주어진 파일로부터 읽은 내용을 덧붙인다.                                                 |
| `R filename`   | 주어진 파일로부터 한 행을 읽어서 덧붙인다. 실행될 때마다 각 행을 읽게 된다.             |

### 어드레스 범위를 받는 명령

| 명령             | 의미                                                                                                                                         |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `{`              | 명령 블럭을 시작한다(블럭은 `}`로 끝난다).                                                                                                   |
| `b label`        | 주어진 라벨로 이동한다. 라벨명이 생략되면 스크립트의 끝으로 이동한다(라벨은 스크립트 내에서 `:label_name`의 형식으로 정의한다).              |
| `t label`        | 마지막으로 읽어들인 라인에 대해서 `s///` 치환 명령이 성공적으로 수행되었다면 해당 레이블로 간다. 레이블명이 생략되면 스크립트의 끝으로 간다. |
| `T label`        | 마지막으로 읽어들인 라인에 대해서 `s///` 치환 명령이 실패했다면 해당 레이블로 간다.                                                          |
| `c \ text`       | 해당 범위를 주어진 텍스트로 치환한다.                                                                                                        |
| `d`              | 해당 패턴 공간을 제거한다.                                                                                                                   |
| `D`              | 패턴 공간으로부터 첫 개행까지를 제거한다.                                                                                                    |
| `h H`            | 패턴의 내용을 홀드 영역으로 복사/추가한다.                                                                                                   |
| `g G`            | 홀드 영역에 복사된 내용을 패턴 공간으로 복사/추가한다.                                                                                       |
| `x`              | 홀드 영역과 패턴 영역의 값을 교체한다.                                                                                                       |
| `l`              | 현재 행을 "시각적으로 명료한 폼"으로 출력한다.                                                                                               |
| `l width`        | 현재 행을 시각적으로 명료한 폼으로 출력하되, 주어진 길이에서 강제 개행한다.                                                                  |
| `p`              | 현재 패턴 공간의 내용을 출력                                                                                                                 |
| `P`              | 현재 패턴 공간으로부터 개행까지 출력                                                                                                         |
| `s/regexp/rep/`  | 주어진 패턴을 대체 패턴으로 교체한다. `&`는 매치된 전체를 의미하며, `\1` ~ `\9`까지의 서브 패턴을 적용할 수 있다.                            |
| `w filename`     | 현재 패턴 공간을 주어진 파일에 쓴다.                                                                                                         |
| `W filename`     | 패턴 공간의 첫 줄을 주어진 파일에 쓴다.                                                                                                      |
| `y/source/dest/` | 소스에 정의된 글자들을 `dest`에 정의된 글자들로 바꾼다.                                                                                      |
| `n` `N`          | 입력 파일로부터 한 줄을 더 읽어들여서 패턴 공간에 복사/이어붙이기 한다.                                                                      |

그 외에 다음과 같은 명령이 있다.

- `#comment` : `#`으로 시작하는 라인은 코멘트로 처리된다.
- `{` ... `}` : 중괄호로 가싸진 영역은 명령 블럭이다. 중괄호 앞/뒤에 다르글자가 와서는 안된다.

## SED의 명령 처리 방식

`sed`는 스트림으로 전달되는 일련의 텍스트를 각각의 행으로 끊어서 처리한다. 읽어들인 한 줄 분량의 버퍼 콘텐츠는 패턴공간이라는 메모리상의 버퍼 영역으로 복사되고, 패턴 공간에 대해 실행 시 주어진 스크립트를 반복적으로 적용한다. 입력된 모든 명령이 해당 패턴 공간에 대해 순차적으로 적용된다.

### 사이클과 패턴공간

`sed`는 패턴스페이스라는 메모리 영역을 사용하여, 입력 장치로부터 한 줄의 문자열을 읽고 다음과 같은 라인 사이클을 돈다.

1. 최초 패턴 공간은 비어 있다.
2. 표준입력으로부터 한 줄의 텍스트를 읽어 패턴 공간에 복사한다.
3. 스크립트에 정의된 각 명령을 패턴 공간에 대해서 수행한다.
4. 패턴 공간의 내용을 출력한다(디폴트 동작).
5. 패턴 공간의 내용을 지운다.
6. 파일의 남은 데이터가 있으면 1로 돌아가서 다음 라인을 처리한다.

각 라인에 대해 라인 사이클을 반복해서 처리하며, 명령에 의해 내용이 조작되는 것은 파일이 아닌 패턴 공간이다. 따라서 원본의 내용은 변경되지 않으며(`-i` 명령을 수행하지 않는 한), 처리된 내용은 표준 출력으로 한 줄씩 내보내진다.

각 라인의 사이클은 최종적으로 패턴 공간으로 읽어들여지고, 조작된 내용을 화면에 출력한 후, 패턴 공간을 비우는 것으로 끝난다.

### 예제

- `regex`라는 단어를 모두 `REGEXP`로 치환하여 표준 출력으로 내보내기:

```sh
sed -e 's/regex/REGEXP/g' infile.txt
```

- `regex`라는 단어를 모두 `REGEXP`로 치환한 결과를 별도의 파일에 저장하기:

```sh
sed -e 's/regex/REGEXP/g' infile.txt > outfile.txt
```

- `regex`라는 단어를 모두 `REGEXP`로 치환한 결과를 원본 파일에 적용하기(원본 파일의 내용이 바뀌게 되므로 주의해야 한다.)

```sh
sed -e 's/regex/REGEXP/g' -i infile.txt
```

- 디폴트로 해당 내용을 출력하는 작업을 생략하는 상태에서(`-n` 플래그 사용), 특정한 명령을 적용하기
  - 스크립트 명령 중 `p`는 현재 패턴 공간의 내용을 출력하게 한다. (즉, 디폴트로 출력되는 상태와 동일해진다)
  
  ```sh
  sed -n -e 'p' infile.txt
  ```

  - 스크립트 명령 중 `=`는 해당 행의 번호를 출력한다(하지만 `-n`에 의해 파일의 내용은 출력되지 않는다)
  
  ```sh
  sed -n -e '=' infile.txt
  ```

`sed`는 명령의 적용 범위인 "어드레스"를 통해, 현재 패턴 공간에 명령을 적용할지의 여부를 결정한다(어드레스가 명시적으로 주어지지 않으면, 전체 라인에 적용된다). 어드레스를 적용하는 방법은 크게 두 가지이다:

1. 숫자 : 숫자는 해당 행의 번호를 의미한다.
2. /정규식/ : `/regex/`의 형태로 정규식의 패턴을 사용하면, 해당 패턴에 매치되는 값이 있는 라인만 적용한다.

어드리스 두 개를 사용하는 경우에는, 각 어드레스를 콤마를 통해 이어붙인다. 각각의 어드레스는 행 번호이거나 정규식일 수 있다. 범위로 주어지는 어드레스는 시작행과 끝행을 포함하는 것에 유의하자.

- 특정한 파일의 1, 2번 행과 끝 행을 삭제하는 경우(두 개의 스크립트 명령은 `;`를 통해 구분한다)

```sh
sed -e '1,2d;$d' infile.txt
```

참고로 `d`명령을 써서 행을 삭제하는 경우, 패턴 공간의 내용이 비어버리므로, 라인 사이클의 끝에서 내용을 출력해주지 않는다. 또한 `-e` 스위치는 두 번 이상 사용될 수 있다(이들은 모두 `;`로 연결한 하나의 덩어리로 인식된다).

```sh
sed -e '1,2d' -e '$d' infile.txt
```

`;`로 구분되는 두 개의 명령은 사이클마다 따로 적용된다. 다음 명령을 보자.

```sh
sed -ne '3,5=;p' infile.txt
```

여기에는 두 개의 명령이 적용되어 있는데,

1. `3, 5=` : 3~5번 라인에서 현재 행 번호를 출력한다.
2. `p` : 모든 라인에서 현재 내용을 출력한다.

따라서 모든 라인이 출력되는 대신에, 3,4,5번 라인에서는 행 번호가 한 줄씩 추가로 출력된다. 만약 3~5번 라인 사이에만 행번호와 해당 행을 출력하고 싶다면? 이 때는 두 `=`, `p` 명령을 하나의 블럭으로 묶으면 된다.

```sh
sed -ne '3,5{=;p}' infile.txt
```

### 심화 예제

- 특정한 두 단어 사이의 내용에 대해 다시 특정 조건을 만족하는 행만 번호와 함꼐 출력

```sh
sed -n -e '/def/,/ return/{ /r[aeiou]/{=;p} }' infile.py
```

위 명령은 다음을 수행한다:

1. `def`, `return` 이라는 단어 사이에 대해서
2. `r모음`의 패턴을 포함하는 라인의
3. 행 번호와 그 내용을 출력

- 빈 줄을 찾아서 해당 행을 줄 번호로 대체하기

```sh
sed -e '/^$/{=;d}' infile.txt
```

아래와 같이 일종의 스크립트를 작성하여 사용할 수도 있다.

```text
# para.sed

/^$/ b print_para    # 빈줄을 발견하는 경우 print_para로 건너뛴다.
H                    # 빈줄이 아닌 경우 이 라인으로 넘어와서 실행하는데, 현재 라인을 홀드영역에 추가한다.
$ b print_para       # 끝줄인 경우에 print_para로 건너뛴다.
b                    # 스크립트의 끝으로 건너뛴다. 따라서 빈줄 및 끝줄이 아닌 경우에는 print_para 가 실행되지 않는다.
:print_para          # print_para 영역. 홀드 영역과 현재 패턴 공간을 바꿔치기 하고, "main"이라는 패턴이 있으면 출력한다.
/main/ p
```

```sh
sed -nf para.sed infile.py
```

홀드, 흐름제어와 같은 보다 자세한 내용은 블로그를 참고! (너무 어렵다 흑흑)

## 정리

`vim`과 같은 시각적 편집기의 도입 이후, 스트림 에디터인 `sed`를 사용하는 일은 극히 드물어졌다고 한다. 하지마 여전히 `sed`는 명령줄 상에서 간단한 편집 작업을 수행할 수 있으며, 그 대상이 파일 뿐만 아니라 표준입력을 통해서 통해 전달받는 텍스트 스트림이 될 수 있기에, 쉡 스크립트 상에서 텍스트 콘텐츠를 다루는데 요긴하게 사용될 수 있다. `awk`와 더불어 명령줄에서 특정한 콘텐츠를 편집하는데 현재도 자주 사용되며, 이 조합을 통해 쉘 스크립트에서 왠만한 스크립팅 언어 수준의 텍스트 처리를 수행할 수 있다고 한다.
