---
title: "2022-03-27-gcccomp"
lang: "ko"
layout: page
date: 2022-03-27 18:56:13 +9000
tags: "Computer"
type: documents
---
<!-- [[Computer]] -->
[해당 포럼](http://forum.falinux.com/zbxe/index.php?mid=gcc&document_srl=555339)에 gcc 컴파일 과정을 쉽게 설명한 내용이 있어 아래에 똑같이 적어본다.

## GCC란?

GCC는 리처드 스톨먼이 만든 GNU 프로젝트의 오픈소스 컴파일러이다. 하지만 GCC는 사실 컴파일러 자체를 말하는 것은 아니고, 컴파일 과정에 필요한 여러가지 기능을 호출하는 역할을 한다. 따라서 GCC는 C언어 뿐만 아니라 다른 언어들도 컴파일할 수 있다.

**[컴파일 과정]**
전처리 과정 -> 어셈플리 소스파일로 컴파일 과정 -> 인스트럭션 코드 생성 과정 -> 링크 과정

1. 전처리 (ccp0)
    - 소스파일에 포함된 (#include) 파일들을 불러와 현재 컴파일할 파일에 복사해서 붙여 넣는다.
    - 결과물: `test.i`
2. 어셈플리 코드로 컴파일 (cc1)
    - 실제 컴파일러라고 할 수 있다.
    - 어휘분석 -> 구문분석 -> 의미분석 -> 중간언어 생성 -> 코드 최적화 -> 목적코드 생성 의 과정을 거친다.
      - 어휘분석: 전처리 과정에서 생성된 `test.i` 파일을 문법적 의미가 있는 최소 단위(토큰)로 나눈다.
      - 구문분석: 문법적 오류가 있는지 검사한 후 파서트리를 만든다.
      - 의미분석: 문법상 문제가 아닌 의미상 문제, 즉 선언되지 않은 변수의 사용이나 자료형 불일치, 함수 인자 개수 등의 문제를 검사한다.
      - 중간언어 생성: 어셈블리 코드로 만들기 전에 최적화를 위해 RTL(Register Transfer Language)라는 lisp 언어와 유사한 코드로 생성한다.
        - 결과물: `test.rtl`
      - 코드 최적화: 코드의 사이즈를 줄이고, 속도를 높이기 위해 최적화를 진행한다. gcc 컴파일의 대부분의 시간이 소요되며, 아래 두 단계를 거친다.
        1) 중간코드 최적화
           - 지역 최적화: 연산강도 경감, 상수 계산 등의 최적화
           - 전역 최적화: 사용되지 않는 코드 제거
           - 루프 최적화: 사용하지 않는 루프 제거, 루프 결합
        2) 목적코드 최적화
           - 최대한 메모리보다 레지스터를 사용하게 하고, 효율적인 인스트럭션을 선택하여 메모리 접근을 최적화한다.
      - 목적코드 생성
        - 최적화된 rtl 코드를 어셈블리 코드로 변환한다.
        - 어셈블리 코드는 CPU마다 정해진 인스트럭션(기계어)과 1:1로 매칭된 코드이다.
        - 결과물: `test.s`
3. 기계어 코드 생성 (as)
    - `test.s`인 어셈블리 코드를 `test.o`인 오브젝트 파일로 바꾼다.
    - 생성된 오브젝트 파일은 ELF(Excutable and Linking) 바이너리 파일 구조 규약을 따르며, 이유는 여러 오브젝트 파일을 링크할 때, 파일의 구조가 다르다면 불가능하기 때문이다.
    - 바이너리 포맷은 a.out / ELF / COFF 등이 유닉스 시스템에서 쓰였으며, 현재는 ELF가 대부분 사용된다.
      - ELF 파일 구조는 맨 위에 ELF 파일 헤더, 프로그램 헤더 Table, 섹션 1 ~ n, 섹현 헤더 테이블로 구분된다.
      - ELF 파일 헤더를 제외하고 나머지는 컴파일된 파일마다 다를 수 있으며, 인스트럭션과 데이터, GCC 컴파일러 버전 등이 기록된다.
4. 링크 (collect2)
    - 여러 개의 오브젝트 파일을 하나로 링크하는 과정이며, 주로 라이브러리 링크가 이루어진다.
      - 정적 라이브러리: 링크 시에 라이브러리를 포함해서 실행 파일을 만든다. 따라서 다른 프로그램에서도 같은 라이브러리를 사용한다면, 중복되기 때문에 용량을 많이 차지하게 되지만, 링크가 완료된 상태이므로 속도는 빠르다.
      - 동적 라이브러리(공유 라이브러리): 링크 시 라이브러리의 포함 여부만 기록하고, 실제 동작할 때 메모리에 라이브러리를 로드하여 사용한다.
        - 다른 프로그램에서 같은 라이브러리를 사용할 경우 메모리에 이미 로드된 것을 사용하므로, 공유한다는 의미에서 공유 라이브러리라고도 한다.
        - 따라서 단 한개의 프로그램이라도 이 라이브러리를 사용하고 있으면, 메모리에 상주하며, 아무 프로그램도 사용하지 않는다면, 메모리에서 제거된다.
        - 실행 시 로드되므로 속도는 다소 느릴 수 있으나, 중복로드 되지 않아 메모리 사용이 효율적이다.
    - 결과물: 실행 파일

재미있는 유닉스 세계!

[Back](/)
