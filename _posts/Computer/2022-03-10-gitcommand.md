---
title: "2022-03-10-gitcommand"
lang: "ko"
layout: page
date: 2022-03-10 17:30:03 +9000
tags: "Computer"
type: documents
---
<!-- [[Computer]] -->
## Git 명령어들

기억력이 안좋아서 그런지, 매번 간단한 git 명령어를 잊어버려 귀찮은 경우가 많다. 그렇기에 여기에 (내 기준으로) 헷갈리는 명령어들을 따로 적어놓는다. 깃허브에 파일을 올리기 위해선, git을 설치해야 하고, 해당 프로젝트에 git을 설정해놓아야 한다.
해당 명령어들을 참고한 [블로그](https://ebbnflow.tistory.com/196?category=842626) (너무나 정리가 잘 되어있다. 압도적 감사!)

## Git 설정

### 초기화(init)

```shell
git init
// 만약 처음 git을 설정한다면, 아래와 같은 닉네임과 이메일을 입력해야 한다.
git config --global user.name "my nickname"
git config --global user.email "my email"
```

### Git 스테이징(add, commit, status)

사실 나는 귀찮아서 `git add .`를 사용하였는데, 이 경우 실제로 추가할 필요가 없는 파일까지 모두 추가가 되고, 어떤 내용이 실제로 커밋에 반영되었는지 감춰지므로 좋지 않은 습관이라고 한다. `git commit -m "메세지"`를 이용하면, 지금까지 추가된 내용들을 git이 추적하여 버전관리를 한다. `git status`는 현재 스테이징된 상태를 확인할 수 있다.

### Git 변경사항 확인 및 되돌리기(log, revert, reset)

`git log`는 커밋된 git의 기록들을 확인할 수 있다. 만약 이전의 커밋으로 되돌아가야 한다면 커밋 기록에 부여된 번호를 작성해야 한다.

* 나의 멋진 git log 설정:

  ```sh
  alias gl="git log --graph --full-history --all --color --date=short --pretty=tformat:\"%x1b[31m%h%x08%x1b[0m%x20%ad %x1b[32m%d%x1b[0m    %s%x20%x1b[33m(%an)%x1b[0m\""
  ```

파일을 이전 상태로 되돌리는 방법은 두 가지가 있다: `git reset`은 이전 상태로 이동하는 과정에서, 그 중간의 모든 기록들을 삭제하기에 이전 상태로 되돌아간 이후 다시 되돌아올 수 없다(노빠꾸 ㄷㄷ). 하지만 `git revert`는 다시 되돌아올 수 있다.

```shell
git reset 되돌아갈 커밋번호 --hard
// or
git revert 삭제할 커밋번호
```

`git revert`가 다시 되돌아갈 수 있는 이유는 **새로운 커밋 상태를 생성하기 때문**이다. `git revert`로 삭제하고 싶은 커밋을 선택하면, 로그에 해당 커밋 위로 Revert 커밋이 새로 생성된다. Revert 커밋은 삭제하고자 하는 커밋의 상태를 덮어쓴다.

## Git branch

branch를 이용하면 다양한 작업들을 독립적으로 수행할 수 있어, 다양한 사람들이 모여 프로젝트를 진행하는 상황에 이점을 준다. 브랜치와 관련된 **용어**들은 다음과 같다:

**마스터 브랜치(Master Branch)**: 기본적으로 저장소에 새로운 파일을 추가하거나 코드를 수정하는 작업을 수행한다.

**통합 브랜치(Integration Branch)**: 프로젝트의 안정적인 상태를 유지하는 브랜치. 일반적으로 마스터 브랜치를 통합 브랜치로 사용한다.

**토픽 브랜치(Topic Branch, Feature Branch)**: 기능 추가나 버그 수정과 같은 단위 작업을 위한 브랜치. 토픽 브랜치는 보통 통합 브랜치로부터 파생하여 생성하고, 특정 작업이 완료되면 통합 브랜치에 병합(merge)하는 방식으로 작업한다.

**체크 아웃(Checkout)**: 다른 브랜치로 전환할 때 사용하는 git 명령어.

**헤드(HEAD)**: 현재 사용중인 브랜치의 선두 부분을 나타내는 이름.

**스태시(Stash)**: stash는 파일의 변경 내용을 일시적으로 기록해두는 영역이다. 커밋하지 않은 변경 내용이나 새롭게 추가한 파일이 _인덱스와 작업 트리에 남아 있는 채로_ 다른 브랜치로 체크아웃하면, 해당 변경 내용들은 이전 브랜치가 아닌, 체크아웃하여 전환된 브랜치에서 커밋할 수 있다. 그런데 커밋 가능한 변경 내용 중, 전환된 브랜치에서도 한 차례 변경이 되어 있을 경우, 체크아웃에 실패할 수 있는데, 이 경우 이전 브랜치에서 커밋하지 않은 변경 내용을 커밋하거나, stash를 이용하여 일시적으로 변경 내용을 다른 곳에 저장해 충돌을 피하게 한 뒤, 체크아웃을 해야한다.

![stash](/attachments/2022-03-10-19-05-44.png)

**머지(Merge)**: 브랜치를 병합하는 명령어.

**리베이스(Rebase)**: merge와 유사하게 브랜치를 통합하지만, merge는 변경 내용의 이력이 모두 남아있어서 이력이 복잡해지지만, rebase는 정확한 이력을 남겨두지 않아, 전체적으로 이력이 단순해진다.

브랜치와 관련된 **명령어**들은 아래와 같다:

### 전체적인 브랜치의 상황을 확인하기

```shell
git log --graph --all --decorate
```

### 브랜치 생성 및 이동(branch, checkout)

특정한 브랜치 생성:

```shell
git branch 브랜치이름
```

브랜치 전환(브런치를 생성하면, _반드시_ checkout을 해주어야, 해당 브랜치로 전환이 된다!)

```shell
git checkout 브랜치이름
```

### 브랜치 병합(merge, rebase)

현재 브런치와 특정 브랜치를 병합하는 경우. 가령 master 브랜치를 다른 브랜치와 병합하고자 한다면, 먼저 maseter 브랜치로 checkout을 해주어야 한다.

```shell
git merge 브랜치이름
// or
git rebase 브랜치이름
```

어떠한 이력을 남겨놓을지 잘 생각하여 두 명령어를 사용하자. 두 브랜치가 서로 같은 파일을 수정하는 경우, 병합 시 conflict가 발생할 수 있으니, 각 브랜치는 서로 다른 파일을 다루는 것이 좋다.

### 브랜치 삭제(-D)

```shell
git branch -D 브랜치이름
```

## Github 연동

깃허브와 연동하기 위해선, 먼저 해당 프로젝트를 저장할 저장소를 먼저 생성해야 한다. 깃허브에서 저장소를 생성할 경우, 저장소의 주소가 만들어지고, 해당 주소를 복사한다(주소의 형식은 `https://github.com/유저네임/저장소이름.git`이다.). 또한 저장소에 로컬 프로젝트를 올리기 위해선, 해당 프로젝트의 작업이 모두 commit 되어 있어야 한다.

모든 준비가 완료되었다면 `git remote` 명령어를 입력하여, 현재 프로젝트 폴더의 원격 저장소를 확인해본다. 저장소를 설정한 적이 없기에 아무런 정보도 뜨지 않아야 한다. 아무런 메세지도 출력되지 않았다면, 다음 명령어를 입력하여 로컬 프로젝트와 원격 저장소를 연결한다.

```shell
git remote add 원격저장소이름 원격저장소주소
```

원격 저장소의 기본 이름은 origin이기에, 많은 사람들이 원격저장소의 이름을 origin으로 설정한다. 또한 원격 저장소 주소의 형식을 잘 확인하자(url 뒤에 .git이 붙는다)

연결이 완료되었다면, 아래 명령어를 입력하여 프로젝트의 코드를 저장소에 올리자:

```shell
git push -u origin master
// 원격저장소이름을 origin으로 설정하고, 기본 브랜치의 이름을 master로 설정하였을 경우.
```

수많은 메세지들이 출력되고, 로컬의 master 브랜치가 원격 저장소 origin의 master를 추적한다는 메세지가 뜨면, 연동이 완료된 것이다. 깃허브 홈페이지에 들어가보면, 로컬에서 작업한 프로젝트가 정상적으로 올라왔을 것이다.

이후 원격 저장소에 코드를 올리고 싶다면, add와 commit을 수행한 후, push하면 된다.

```shell
git push origin master
```

만약 깃허브에 올리고 싶지 않은 정보가 있다면, 프로젝트에 `.gitignore` 파일을 만들어, 그 안에 내용을 저장해놓자.

## 원격 저장소 소스 내려 받기

저장소의 소스를 로컬에 내려받기 위해선, 우선 해당 원격 저장소로 이동 후, 초록색 버튼으로 표시된 `clone or download`를 클릭하고, 원격 저장소 주소를 복사한다.

그리고 로컬에 새로운 폴더 하나를 만들고, 해당 폴더로 들어가 다음 명렬어를 입력한다:

```shell
git clone 원격저장소주소
```

해당 폴더에 해당 원격 저장소의 코드가 담겨있는 폴더가 생성된 모습을 확인할 수 있다. 원격 저장소의 폴더로 들어가 `git log`를 입력하면, 원격 저장소의 프로젝트에서 이루어진 작업의 기록들이 모두 보존되어 있는 모습을 볼 수 있다.

## 원격 저장소 정보 가져오기

만약 어떤 원격 저장소를 다른 사람들도 사용하고 있거나, 서로 다른 기기에서 하나의 원격 저장소를 기준으로 작업을 공유해야 하는 경우, 해당 원격 저장소의 작업 상태에 맞춰 로컬의 작업을 원격 저장소에 올려야 한다. 이를 확인하기 위해선 다음의 명령어를 입력하자:

```shell
git fetch
git status
```

fetch 명령어를 입력하면, 원격 저장소의 현 상태를 로컬에서 확인할 수 있고, 이후 status를 입력하면, 원격 origin의 master 브랜치와 비교하여, 현재 로컬의 브랜치의 커밋 상태가 어떠한지 알 수 있다. 만약 커밋 하나가 원격 저장소의 브랜치보다 하나 뒤쳐져 있다면, 아래 명령어를 입력하여 로컬에 다운로드를 해야한다.

```shell
git pull 원격저장소이름 브랜치명
```

위와 같이 fetch와 status로, 현재 로컬 프로젝트가 pull할 내용이 있는지 확인해야, conflict를 방지할 수 있다.

더 추가해야 할 내용이 있으면 이후에 추가할 예정!

[Back](/)
